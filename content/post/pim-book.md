---
title: "A Programmer's Introduction to Mathematics"
date: 2019-12-24T13:12:09+01:00
draft: false
tags: ["review", "math"]
categories: ["2019"]
---

Here is a short review of [*A Programmer's Introduction to Mathematics*](https://pimbook.org), by Jeremy Kun. Source code is available on [Github](https://github.com/pim-book/programmers-introduction-to-mathematics), and the author has a nice [blog](https://jeremykun.com), which I subscribed to long ago. I've been reading this book erratically since this summer, and finally got to the last few chapters. I've heard there's another book in preparation, this time about a mathematical introduction to programming. This should come as no surprise since the author refers to Knuth's artwork on mathematics and programming here and there ("Mathematics provides an abstraction that helps one be sloppy in a precisely controlled way"; *Concrete Mathematics*). A related publication is *Programming and Mathematical Thinking: A Gentle Introduction to Discrete Math Featuring Python*, by Allan M. Stavely (The New Mexico Tech Press, 2014).

"Like Programming, Mathematics has a Culture." So you need to embrace the whole field of mathematics, and its historical development.

> (T)he best mathematicians study concepts that connect decades of material, while simultaneously inventing new concepts which have no existing words to describe them. Without flexible expression, such work would be impossible. It reduces cognitive load, a theme that will follow us throughout the book. Unfortunately, it only does so for the readers who have already absorbed the basic concepts of discussion. By contrast, good software practice encourages code that is simple enough for anyone to understand. As such, the uninitiated programmer often has a much larger cognitive load when reading math than when reading a program.

The book reviews a number of concepts ranging from basic and abstract algebra, discrete structures (sets and graphs), and uni- and multivariable calculus. All those domains are closely related to programming, as matter of fact. Each chapter is followed by some exercises, that can be discussed on [Github](https://github.com/pim-book/exercises). 

Much like in the [preceding book](/post/bioinformatics-algorithms/) I discussed, the author keeps an approach aimed at a wide audience without sacrificing technical precision:

> For now, think of a real number as a floating point number without the emotional baggage that comes from trying to fit all decimals into a finite number of bits.

For instance, a well-known theorem states that there is a unique degree *n* polynomial passing through a choice of *n* + 1 points. As a statistician I immediately think of the classical overfitting issue in parametric modeling, or Taylor expansion. The author emphasizes the role of polynomials as building blocks, for they can be seen as families of increasingly expressive objects (p. 9). He then spend a couple of pages demonstrating the uniqueness of the above polynomial passing through *n* points, starting from a single point (*x*<sub>1</sub>, *y*<sub>1</sub>) and the relation $f(x) = \sum_{i=0}^ny_i\left(\prod_{j\ne i}\frac{x - x_j}{x_i - x_j}\right)$. All becomes crystal clear as we progress in the logic of the demonstration. This is the guiding theme of this book: to get the reader to think about key concepts based on simple cases as well as practical illustrations using Python snippets (in the case of polynomials, a complete example of interpolation via polynomial fitting followed by an application of code deciphering). I slightly disagree with the idea that "in mathematics, we place a special emphasis on the communication of ideas from human to human", since I often came across some obscure answer on Mathoverflow or elsewhere, where folks wrote a post full of mathematical symbols with no connection to human language --- at least if we agree that a human language usually means an articulated succession of words in English (or French in my case) that can be associated to relevant meaning. Anyway, that's a minor issue since this is clearly not the case of this book, which contains a much larger portion of text than mathematical equation.

Even if the author mainly uses Python to illustrate the core ideas of each chapter, there are some  reference to Haskell and I found it nice given the expressiveness of Haskell with regard to mathematical equation. For example, in the chapter dealing with sets, the set of all nonnegative numbers divisible by seven can be written as $S = \left\{ x: x \in \mathbb{N}, x\, \text{is divisible by}\, 7 \right\}$. This readily translates to the following infinite list comprehensions in Haskell: `[x | x <- [1..], mod x 7 == 0]`. Figure 4.4 (p. 50) is also a beauty: it shows how the equality ${n \choose 2}=1+2+\dots+n-1$ (i.e., the number of ways to choose two objects from a set of *n* objects) could be demonstrated using a bijection. Here's the idea with seven objects, $X=\left\{A, B, \dots, G\right\}$: A bijection $g: Y\rightarrow {X \choose 2}$ can be constructed by drawing two arrows at an angle from any ball to the corresponding pair of squares, $g(y)$. Each choice of balls give two different diagonals, hence it is an injection; given a pair $(x_1,x_2) \in X$, the inner diagonals meet a unique ball at $y$, so $g$ is a surjection. 

![](/img/balls.png)

The chapter on graphs was also delightful, for it highlights important properties of graphs "in picture". For instance, the *k*-coloring of a [Petersen graph](https://en.wikipedia.org/wiki/Petersen_graph) is used to discuss how to partition the set of vertices into color classes, with edges going from one color class to another. The characteristic property of a planar graph, which can be drawn on a plane in such a way that no edges cross, whereby the Euler characteristic *V* âˆ’ *E* + *F* = 2 is also demonstrated using plain language. The author also uses the [igraph](https://igraph.org) package to demonstrate how to perform 5-coloring of a planar graph.

Note that in addition to exercises at the end of each chapter, between each of the main chapters there is a reflection chapter on the cultures or subcultures of Mathematics (e.g., chapters 5 and 7). There's more to see in the next chapters which deal more specifically with linear algebra and calculus. If you're interested in applied mathematics, or how it relates to everyday programming, read the very [first pages](https://pimbook.org/pdf/pim_first_pages.pdf) and go checkout the rest of the book.