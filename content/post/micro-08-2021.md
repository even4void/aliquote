---
title: "Micro posting in August"
date: 2021-08-30T13:39:57+02:00
draft: false
tags: ["micro"]
categories: ["2021"]
---

<a href="#" style="text-decoration: none;">2021-08-02</a>:

> What's the difference? Why do all those formal doo-hickeys matter?<br> Performance! Compiled languages are fast. Lisp is WAY faster than Ruby, over the long haul. Smokes it. --- [the-emacs-problem](https://sites.google.com/site/steveyegge2/the-emacs-problem)<br>

<a href="#" style="text-decoration: none;">2021-08-03</a>: Tonight I top at less than 2 Go of RAM. Great, especially since I'm only using Gnome terminal and a bunch of child processes, after 2 days uptime. Never happened when I was on macOS.<br>![img](/img/2021-08-03-21-15-05.png)<br>
<a href="#" style="text-decoration: none;">2021-08-04</a>:

> After 10+ years of Linux distributions pushing CUPS on me. Over a decade of this complex stack of drivers and daemons that I never quite trusted but “couldn’t live without.” FreeBSD comes along and is like “yeah, just use netcat.” And they’re right. Just use netcat. --- [Bye CUPS: Printing with netcat](https://retrohacker.substack.com/p/bye-cups-printing-with-netcat)<br>

<a href="#" style="text-decoration: none;">2021-08-04</a>:

> Checking news once a day is enough. --- [The Old Computer Challenge: 10 days later, what changed?](https://dataswamp.org/~solene/2021-07-26-old-computer-challenge-after.html)<br>

<a href="#" style="text-decoration: none;">2021-08-04</a>: It looks like the new "Now" thing is: [Uses](https://uglyduck.ca/sharing-the-things-we-use/) (via [Kev Quirk](https://kevq.uk/notes/adding-a-uses-page/)). Here is mine, but it's called [How I do](/articles/how-i-do/).<br>
<a href="#" style="text-decoration: none;">2021-08-04</a>: TIL about [rusty-man](https://sr.ht/~ireas/rusty-man/), which is pretty handy to have a look at the Rust doc from a terminal. `#rust`<br>
<a href="#" style="text-decoration: none;">2021-08-04</a>: Using an Apple Magic Mouse on Ubuntu is kind of magic and ironic, yet it's still better than PC touchpad. I should note that Bluetooth is working fine on Linux machines compared to 15 years ago...<br>
<a href="#" style="text-decoration: none;">2021-08-04</a>: [Collatz analog in C](http://feedproxy.google.com/~r/TheEndeavour/~3/Z6skvdnCIBg/).<br>
<a href="#" style="text-decoration: none;">2021-08-04</a>: [Leap seconds: Causing Bugs Even When They Don't Happen](https://berthub.eu/articles/posts/leapseconds-expose-bugs-even-when-they-dont-happen/).<br>
<a href="#" style="text-decoration: none;">2021-08-05</a>: <br>![img](/img/IMG_1624.JPG)<small>Today's art discount on the balcony.</small><br>
<a href="#" style="text-decoration: none;">2021-08-06</a>:

> Build your own tools for repeated workflows. There is nothing faster than using a tool you made yourself. --- [Reflections on 10,000 Hours of Programming](https://matt-rickard.com/reflections-on-10-000-hours-of-programming/?utm_source=pocket_mylist)<br>

<a href="#" style="text-decoration: none;">2021-08-06</a>: [Everything you need to know to configure neovim using lua](https://vonheikemen.github.io/devlog/tools/configuring-neovim-using-lua/). `#vim`<br>
<a href="#" style="text-decoration: none;">2021-08-19</a>: <br>![img](/img/IMG_1638.JPG)<small>Fuschia on the balcony</small><br>
<a href="#" style="text-decoration: none;">2021-08-19</a>: Old times good times: <http://tapedeck.org/>.<br>
<a href="#" style="text-decoration: none;">2021-08-19</a>: TIL that `<C-R>.` (mind the leading dot) allow to paste the last piece of inserted text. `#vim`<br>
<a href="#" style="text-decoration: none;">2021-08-19</a>: [Highlights from Git 2.33](https://github.blog/2021-08-16-highlights-from-git-2-33/). `#git`<br>
<a href="#" style="text-decoration: none;">2021-08-19</a>: [Programming Idioms](https://programming-idioms.org/). Interesting to quickly compare the syntax of different PLs to perform the same task.<br>
<a href="#" style="text-decoration: none;">2021-08-20</a>:

> I am one of those people who came to Racket because it is a Lisp. I feel that I should be better at creating/using software and general problem solving than I am, and I guess you could say I am looking for the fabled Lisp enlightenment. Maybe saying Lisp is the language of the gods is overwrought, but nobody ever said that JavaScript made them smarter, or that they learned a lot using anything by Microsoft. --- [Thoughts On Lisp And Racket](https://www.macadie.net/2019/08/11/thoughts-on-lisp-and-racket/)See comments and interesting side discussions on [Hacker News](https://news.ycombinator.com/item?id=28179463).<br>

<a href="#" style="text-decoration: none;">2021-08-20</a>: Here's an interesting list of resources in addition to StatLib: [Statistics, Statistical Computing, and Mathematics](https://www.pibburns.com/statmath.htm).<br>
<a href="#" style="text-decoration: none;">2021-08-20</a>: [Computational Statistics in Python](https://people.duke.edu/~ccc14/sta-663/). `#python`<br>
<a href="#" style="text-decoration: none;">2021-08-20</a>: [Exploring Clang/LLVM optimization on programming horror](https://blog.matthieud.me/2020/exploring-clang-llvm-optimization-on-programming-horror/). `#clang`<br>
<a href="#" style="text-decoration: none;">2021-08-20</a>: [Fun with regular expressions: part I](https://yurichev.com/news/20210819_RE1/). Actually, it's quite an interesting read since this post is just a succession of C code, interesting to read by the way, based on DFA representations of regexes.<br>
<a href="#" style="text-decoration: none;">2021-08-20</a>: [Let's write a compiler, part 1](https://briancallahan.net/blog/20210814.html).<br>
<a href="#" style="text-decoration: none;">2021-08-21</a>:

> However, we shouldn’t forget that we are still living in the stone age of computational science. Fortran was the Paleolithic, Python is the Neolithic, but we have to move on. --- [Exploring Racket ](https://khinsen.wordpress.com/2014/05/10/exploring-racket/)<br>

<a href="#" style="text-decoration: none;">2021-08-21</a>:

> The "true" program does nothing; it merely exits with a zero exit status. This can be done with an empty file that's marked executable, and that's what it was in the earliest unix system libraries. Such an empty file will be interpreted as a shell script that does nothing, and since it does this successfully, the shell exits with a zero exit status. --- [The /bin/true Command and Copyright](http://trillian.mit.edu/~jc/humor/ATT_Copyright_true.html)<br>

<a href="#" style="text-decoration: none;">2021-08-21</a>: [An Opinionated Guide to xargs](https://www.oilshell.org/blog/2021/08/xargs.html). `#unix`<br>
<a href="#" style="text-decoration: none;">2021-08-21</a>: [Benefits of not using an IDE](https://alexander-hansen.dev/blog/benefits-of-not-using-an-ide). Main point as far as I'm concerned is that even light IDEs (e.g., VS Code) are too complex for what I really need to do. Git and debugger integration are a plus, though, but I already get that using Emacs or Vim.<br>
<a href="#" style="text-decoration: none;">2021-08-21</a>: [Using Vim - Beyond the Basics](https://www.radford.edu/~nokie/vim/spr08/beyond.html). `#vim`<br>
<a href="#" style="text-decoration: none;">2021-08-24</a>:

> For making a viable Google competitor, I believe that ranking is a harder problem than indexing, but even if we just look at indexing, there are individual domains that contain on the order of one trillion pages we might want to index (like Twitter) and I'd guess that we can find on the order a trillion domains. If you try to configure any off-the-shelf search index to hold an index of some number of trillions of items to handle a load of, say, 1/100th Google's load, with a latency budget of, say, 100ms (most of the latency should be for ranking, not indexing), I think you'll find that this isn't trivial. --- [I could do that in a weekend!](https://danluu.com/sounds-easy/)<br>

<a href="#" style="text-decoration: none;">2021-08-24</a>:

> To a language designer, Racket is a programming language laboratory. That is, Racket comes with a unique collection of linguistic mechanisms that enable the quick construction of reliable languages, language fragments, and their composition. These tools are so easy to use that plain programmers can design a language after a little bit of instruction. So when a well-trained programmer decides that none of the available dialects is well-suited for a task, he designs a new dialect and writes his program in it. As Paul Hudak said, “the ultimate abstraction is a domain specific language.” --- [Racket is...](https://felleisen.org/matthias/Thoughts/Racket_is____.html)<br>

<a href="#" style="text-decoration: none;">2021-08-24</a>: [Euler's Formula](https://susam.in/cafe/euler-formula.html). Looks like a nice Lisp-based website, right?<br>
<a href="#" style="text-decoration: none;">2021-08-24</a>: [Is Hacker News a Good Predictor of Future Tech Trends?](https://jamespotter.dev/hacker-news-tech-trends/).<br>
<a href="#" style="text-decoration: none;">2021-08-24</a>: [Using Emacs in an IDE world](https://andrewjudson.com/emacs/2021/08/23/emacs.html). IDEs all look too complex to me. I am happy with fine-grained text editors like Emacs or (Neo)vim. Every time I try to use a light (VS Code) or not so light (IntelliJ stuff) IDE, I blow up after 10'.<br>
<a href="#" style="text-decoration: none;">2021-08-25</a>:

> BSD is designed. Linux is grown. Perhaps that's the only succinct way to describe it, and possibly the most correct. --- [BSD vs Linux](https://www.over-yonder.net/~fullermd/rants/bsd4linux/01)<br>

<a href="#" style="text-decoration: none;">2021-08-25</a>:

> Emacs, for me, is essentially the definition of tooling alcoholism because I can happily spend hours configuring it without actually achieving much at all.<br> Some of this extends to tools like org-agenda too. There’s a temptation to have Emacs do it all and so I end up breaking my existing systems just to make them fit. --- [Emacs probably isn't right for me](https://utf9k.net/blog/emacs-probably-isnt-right-for-me/)<br>

<a href="#" style="text-decoration: none;">2021-08-25</a>: > o, why is the continuation monad the mother of all monads? The short answer is that, by enabling transparent inversion of control, it eliminates the need to sprinkle hooks for monad-specific code everywhere; normal (as much as anything involving delimited continuations can be “normal”) evaluation rules will be subverted as needed. --- [All you need is call/cc](https://pvk.ca/Blog/2013/09/19/all-you-need-is-call-slash-cc/)<br>
<a href="#" style="text-decoration: none;">2021-08-25</a>: [Moldable Emacs: Vega-Lite, Nyxt and Emacs towards sustainable development](https://ag91.github.io/blog/2021/08/22/moldable-emacs-vega-lite-nyxt-and-emacs-towards-sustainable-development/). `#emacs`<br>
<a href="#" style="text-decoration: none;">2021-08-25</a>: [The missing method: Deleting from Okasaki's red-black trees](https://matt.might.net/articles/red-black-delete/). `#racket`<br>
<a href="#" style="text-decoration: none;">2021-08-25</a>: [Why I recommend CGI instead of web frameworks](https://halestrom.net/darksleep/blog/046_cgi/).<br>
<a href="#" style="text-decoration: none;">2021-08-26</a>:

> Ranking is a farce. Apparent performance is actually attributable mostly to the system that the individual works in, not to the individual himself. --- [Statistical process control after W. Edwards Deming](https://www.2uo.de/deming/)<br>

<a href="#" style="text-decoration: none;">2021-08-26</a>:

> The web is a continuum. It's like my old analog TV. It’s not exactly like DTV. Nor can it match it in some areas of functionality. It does, however, have other strengths. When digital TV fails, it fails completely. Analog TV, to use parlance of the web, degrades gracefully. The web could be similar, if we choose to make it so. It could be “the analog” web in contrast to “the digital” platforms. Perhaps in our hurry to replicate and mirror native platforms, we're forgetting the killer strength of the web: universal accessibility. --- [The Analog Web](https://blog.jim-nielsen.com/2017/the-analog-web/)<br>

<a href="#" style="text-decoration: none;">2021-08-26</a>: [Burning out and quitting](https://mayakaczorowski.com/blogs/burnout).<br>
<a href="#" style="text-decoration: none;">2021-08-26</a>: [Evaluating Compression with Pareto, Docker and Gnuplot](https://jdlm.info/articles/2017/05/01/compression-pareto-docker-gnuplot.html).<br>
<a href="#" style="text-decoration: none;">2021-08-26</a>: [The Mathematics of 2048: Optimal Play with Markov Decision Processes](https://jdlm.info/articles/2018/03/18/markov-decision-process-2048.html).<br>
<a href="#" style="text-decoration: none;">2021-08-26</a>: [Why are hyperlinks blue?](https://blog.mozilla.org/en/internet-culture/deep-dives/why-are-hyperlinks-blue/). TL;DR Mosaic former project use blue in its release notes.<br>
<a href="#" style="text-decoration: none;">2021-08-27</a>:

> Mathematics has no side effects.<br> Math cannot modify the value of a variable--either global or local. It cannot mutate an element in an array. And, a mathematical function always returns the same value for the same input.<br> The literal rendering of mathematics into code cannot contain side effects.<br> Mathematics is a purely functional language. --- [Translating math into code](https://matt.might.net/articles/discrete-math-and-code/)<br>
